# 执行过程

1. 若匹配全局参数，配置全局变量
2. 若匹配子命令，向收集器队列尾加入对应收集器对象
3. 若在子命令后匹配到其参数，相应地对收集器队尾元素（也就是当前子命令对应的收集器对象）的配置进行修改
4. 若再次匹配到全局参数，则再次配置全局变量
5. 解析完成获得一个初始化完成的收集器队列
6. 若全局中配置了被跟踪命令，则创建一个子进程来执行，并获取其pid设置为被监测pid
7. 遍历收集器队列，为每个收集器设置要跟踪的目标pid，然后加载收集器的eBPF程序，然后挂载
8. 若有被跟踪子进程则唤醒
9. 间隔固定时长，对收集器进行遍历，输出收集器收集的数据
10. 监测时间耗尽、收到退出信号或设置的被检测指令退出时，遍历收集器队列中的对象进行eBPF程序销毁

# 使用方法

若要添加一个名为 `<name>` 的eBPF调用栈采集功能，则可以项目根目录下运行如下命令

```shell
new_ebpf.sh <name>
```
详细过程请阅读脚本。

然后按照如下说明分别进行修改。

## include/bpf/<Name>StackCollector.h 

1. 若计数变量类型为自定义结构体，则在`C code part`中定义，以便eBPF程序代码`<name>.bpf.c`可以使用。 
2. 若数据标度`scale`在包装类`class <name>`初始化插入收集器队列时无法确定，请声明一个根据传入参数设定scale的方法`setScale`，在相应的子命令参数解析时进行调用。
3. 可声明其他辅助函数

## src/bpf/<Name>StackCollector.cpp

1. 实现包装类初始化函数，若数据标度`scale`的值可以确定，请在此初始化
2. 若标度无法确定，则实现`setScale`，对标度及包装类参数进行设置
3. 实现一系列虚函数：`count_values, load, attach, detach, unload`
4. 可实现一些辅助函数

## src/bpf/<name>.bpf.c

1. 通过修改`COMMON_MAPS(__u32)`中的`__u32`设置计数变量类型
2. 可声明额外的map和全局变量在eBPF程序内部使用，但不会被框架输出。
3. 实现eBPF程序，请使用通用的`eBPF map`进行数据存储，使用通用的全局变量进行进程和数据过滤，否则无法正确输出数据
    
    通用的map分别为：
    1. psid_count_map：键为psid类型，值为 1. 中设置的计数变量类型
    2. sid_trace_map：键为uint32类型，标识唯一的栈嗲用路径，值为void*[]类型，存储栈上的调用地址
    3. pid_tgid：键为uint32类型，表示pid，值为uint32类型，表示tgid
    4. pid_comm：键为uint32类型，表示pid，值为comm类型，表示进程名

    通用的全局变量分别为：
    1. u，k：分别表示是否采集用户栈和内核栈
    2. min，max：表示计数变量的大小界限
    3. self_pid：表示本项目运行时的pid
4. 可增加额外的全局变量和map。

## main.cpp

向`<Name>Option`中添加自定义选项